{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1031\deflangfe1031{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f34\froman\fcharset238\fprq2 Times New Roman CE;}{\f35\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f37\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f38\froman\fcharset162\fprq2 Times New Roman Tur;}{\f39\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f40\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f41\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f42\fswiss\fcharset238\fprq2 Arial CE;}{\f43\fswiss\fcharset204\fprq2 Arial Cyr;}{\f45\fswiss\fcharset161\fprq2 Arial Greek;}{\f46\fswiss\fcharset162\fprq2 Arial Tur;}{\f47\fswiss\fcharset177\fprq2 Arial (Hebrew);}
{\f48\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f49\fswiss\fcharset186\fprq2 Arial Baltic;}{\f50\fmodern\fcharset238\fprq1 Courier New CE;}{\f51\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f53\fmodern\fcharset161\fprq1 Courier New Greek;}
{\f54\fmodern\fcharset162\fprq1 Courier New Tur;}{\f55\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f56\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f57\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;
\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;
\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \snext0 Normal;}{
\s1\ql \fi-3600\li3600\ri0\keepn\nowidctlpar\faauto\outlinelevel0\adjustright\rin0\lin3600\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext0 heading 1;}{
\s2\ql \fi-5040\li5040\ri0\keepn\nowidctlpar\faauto\outlinelevel1\adjustright\rin0\lin5040\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext0 heading 2;}{
\s3\qc \li0\ri0\keepn\nowidctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f2\fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext0 heading 3;}{
\s4\ql \li0\ri0\keepn\nowidctlpar\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext0 heading 4;}{\s5\ql \li0\ri0\keepn\nowidctlpar\faauto\outlinelevel4\adjustright\rin0\lin0\itap0 
\b\f1\fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}{\s15\ql \fi-1440\li1440\ri0\nowidctlpar\faauto\adjustright\rin0\lin1440\itap0 
\fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext15 Body Text 2;}{\s16\ql \fi-2160\li2160\ri0\nowidctlpar\faauto\adjustright\rin0\lin2160\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext16 
Body Text Indent 2;}{\s17\ql \fi-450\li4320\ri0\nowidctlpar\faauto\adjustright\rin0\lin4320\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext17 Body Text Indent 3;}{
\s18\ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 \sbasedon0 \snext18 Body Text;}}{\*\listtable{\list\listtemplateid1487837312\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0
\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-405\li405\jclisttab\tx405 }{\listname ;}\listid455953827}
{\list\listtemplateid-509965818\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 
\fi-720\li1440\jclisttab\tx1440 }{\listname ;}\listid494613019}{\list\listtemplateid1514423504\listsimple{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat7\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}
\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-720\li1440\jclisttab\tx1440 }{\listname ;}\listid1055155144}}{\*\listoverridetable{\listoverride\listid494613019\listoverridecount0\ls1}{\listoverride\listid1055155144\listoverridecount0\ls2}
{\listoverride\listid455953827\listoverridecount0\ls3}}{\info{\title EXMON}{\author Gordon L Craig}{\operator Mark Usher}{\creatim\yr1999\mo8\dy11\hr17\min17}{\revtim\yr1999\mo8\dy15\hr19\min59}{\version5}{\edmins0}{\nofpages11}{\nofwords3642}
{\nofchars20763}{\*\company  }{\*\hlinkbase http://members.magnet.at/marku/bbc.htm}{\nofcharsws25498}{\vern8247}}\widowctrl\ftnbj\aenddoc\hyphhotz425\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120
\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind1\viewscale129\viewzk2\nolnhtadjtbl \fet0\sectd \linex0\headery709\footery709\colsx709\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2
\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}\pard\plain \qc \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\b\fs48\cgrid0 EXMON
\par }{\b\f1\fs28\cgrid0 -EPROM VERSION-
\par BEEBUG MACHINE CODE MONITOR
\par FOR THE BBC MICRO MODEL A OR B
\par }\pard\plain \s3\qc \li0\ri0\keepn\nowidctlpar\faauto\outlinelevel2\adjustright\rin0\lin0\itap0 \b\f2\fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20 By Mark Tilley
\par }\pard\plain \qc \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\b\f2\fs24\cgrid0 
\par }{\b\fs36\cgrid0 CONTENTS
\par 
\par {\pntext\pard\plain\b\fs36\cf1\lang1033\langfe1031\cgrid0\langnp1033 \hich\af0\dbch\af0\loch\f0 1.\tab}}\pard \ql \fi-720\li1440\ri0\nowidctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec\pnstart1\pnindent360\pnsp120\pnhang{\pntxta .}}
\faauto\ls1\adjustright\rin0\lin1440\itap0 {\b\fs36\cf1\cgrid0 INTRODUCTION\tab \tab \tab \tab \tab 2
\par }\pard \ql \li720\ri0\nowidctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\fs36\cf1\cgrid0 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs36\cf1\cgrid0 \tab }{\b\fs36\cf1\cgrid0 2.\tab STARTING INSTRUCTIONS\tab \tab \tab 3
\par }{\b\f1\fs36\cf1\cgrid0 \tab 
\par }\pard \ql \fi720\li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\fs36\cf1\cgrid0 3.\tab GENERAL OVERVIEW\tab \tab \tab \tab 4
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs36\cf1\cgrid0 \tab 
\par }\pard \ql \fi720\li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\fs36\cf1\cgrid0 4.\tab LISTING AND EDITING COMMANDS\tab 7
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs36\cf1\cgrid0 \tab 
\par }\pard \ql \fi720\li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\fs36\cf1\cgrid0 5.\tab RELOCATION\tab \tab \tab \tab \tab \tab 10
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs36\cf1\cgrid0 \tab 
\par }\pard \ql \fi720\li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\fs36\cf1\cgrid0 6.\tab DEBUGGING AND SIMULATION\tab \tab 12
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs36\cf1\cgrid0 \tab 
\par {\pntext\pard\plain\b\fs36\cf1\lang1033\langfe1031\cgrid0\langnp1033 \hich\af0\dbch\af0\loch\f0 7.\tab}}\pard \ql \fi-720\li1440\ri0\nowidctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec\pnstart7\pnindent360\pnsp120\pnhang{\pntxta .}}
\faauto\ls2\adjustright\rin0\lin1440\itap0 {\b\fs36\cf1\cgrid0 COMMAND SUMMARY\tab \tab \tab \tab 15
\par }\pard \ql \li720\ri0\nowidctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\fs36\cf1\cgrid0 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\f2\fs24\cgrid0 \~
\par Copyright (C) 1983, BEEBUG Publications Ltd. All rights reserved. No part of this manual may be reproduced by any means without prior consent of the copyright holder.
\par The accompanying computer program EXMON, which is supplied in EPROM, is also subject to copyright. No part of EXMON shall be copied for any purpose.
\par Published by BEEBUG Publications Ltd., P0 BOX 50, St Albans, Herts, ALl 2AR, England.
\par Project Editor: D E Graham
\par \page 
\par {\pntext\pard\plain\b\f1\fs36\lang1033\langfe1031\cgrid0\langnp1033 \hich\af1\dbch\af0\loch\f1 1.\tab}}\pard \qc \fi-405\li405\ri0\nowidctlpar\jclisttab\tx405{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec\pnstart1\pnindent360\pnsp120\pnhang{\pntxta .}}
\faauto\ls3\adjustright\rin0\lin405\itap0 {\b\f1\fs36\cgrid0 INTRODUCTION
\par }\pard \qc \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs36\cgrid0 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 EXMON is a sophisticated machine code monitor written especially for the BBC micro (model A or B). In its current form it is supplied
 in EPROM, and provides a wide range of facilities including the following:
\par 
\par }\pard \ql \li720\ri0\nowidctlpar\faauto\adjustright\rin0\lin720\itap0 {\fs24\cgrid0 (i)\tab Register display and alteration
\par (ii)\tab Disassembler, hex dump, editing commands.
\par (iii)\tab Disassemble and save to file for later reassembly.
\par (iv)\tab Disassembly of paged ROMs, including Basic.
\par (v)\tab Line assembler, with labels allowed.
\par (vi)\tab Memory move, verify, search, fill.
\par (vii)\tab Full expression analysis including variable/label names.
\par (viii)\tab Relocator.
\par (ix)\tab Single step tracing of program.
\par (x)\tab Full breakpoint handler.
\par (xi)\tab Allows use of all Operating System commands within the monitor.
\par \~
\par \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 
EXMON is particularly useful for debugging machine code programs. If you have the assembly listing of the program to be debugged, you can enter and edit the assembly language source code using Basic, a
ssemble it and then type *EXMON to enter the monitor. Indeed, *EXMON can be a line of the source code program, so that EXMON is entered automatically after the program has been assembled. You may also make use of the function keys to call EXMON, and to en
ter frequently used commands. For example *KEY0 D3000 3FFF|M <return> will cause EXMON to disassemble memory from &3000 whenever function key f0 is pressed.
\par NOTE To take full advantage of all the features of EXMON, your machine should be fitted with Acorn's
 Basic ROM version I or II. 'To check which version you have, switch on your machine from cold, and type REPORT then press Return. A copyright message will appear with the year 1981 or 1982 on it, for Basic I and II respectively.
\par \~
\par \page \~
\par }\pard \qc \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs36\cgrid0 2. STARTING INSTRUCTIONS
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par (i) Fitting
\par }{\fs24\cgrid0 EXMON is supplied in an 8K EPROM, which should be fitted in one of the "Paged ROM" sockets in the computer. It should be installed to the left of the Basic ROM. See separate fitting sheet for full installation instructions.
\par }{\b\f1\fs24\cgrid0 
\par (ii)}{\f1\fs24\cgrid0  }{\b\f1\fs24\cgrid0 Calling Exmon
\par }{\fs24\cgrid0 
Once the EPROM has been installed, EXMON can be entered by the command *EXMON <return>, where <return> means press the Return key. This can be abbreviated to *E <return> for quick access. (NOTE that there is no full stop after *E ). So that f
ull use of EXMON can be made, this command should be entered from Basic and not, for example, from a word processor EPROM. Pressing break at any time during the running of EXMON will clear all settings and re-enter EXMON. To quit EXMON, type Q-(or use CTR
L,/Break). Type OLD <return> to recover any resident Basic (or assembler) program.
\par }{\b\f1\fs24\cgrid0 
\par (iii) Exmon Version
\par }{\fs24\cgrid0 When in Basic, typing *HELP followed by Return will give the normal Help message, this should now include EXMON with its version number. please quote the version number in any correspondence.
\par 
\par }\pard \qc \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\f1\fs28\cgrid0 \~
\par }{\b\f1\fs36\cgrid0 \page 3. GENERAL OVERVIEW
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par (i)}{\f1\fs24\cgrid0  }{\b\f1\fs24\cgrid0 Commands
\par }{\fs24\cgrid0 Commands are entered by means of one or two characters to identify the command, followed by a number of parameters. The command summary at the end of the manual gives a detailed description of the precise syntax and default values.
\par There is also a HELP facility within EXMON which will give a brief on-screen summary of the commands, this is activated by typing '?'
\par Throughout this manual the following will be used to describe the parameters:
\par \tab 
\par <address>\tab a 2 byte hex address, e.g. 64EA.\tab \~\tab 
\par <range>\tab a range in memory specified by a\tab 
\par \~\tab \~\tab 2 byte start address and a 2\tab 
\par \~\tab \~\tab byte end address, e.g\tab 
\par \~\tab \~\tab 4000 48A1.\tab \~\tab 
\par <byte>\tab \tab a single byte hex value,\tab 
\par \~\tab \~\tab e.g. 3A.\tab \~\tab 
\par \~
\par }{\b\f1\fs24\cgrid0 (ii) Numbers
\par }{\fs24\cgrid0 The numbers used by the commands can be entered in several ways:
\par }\pard \ql \li360\ri0\nowidctlpar\faauto\adjustright\rin0\lin360\itap0 {\fs24\cgrid0 (a)\tab as a simple hex numbe
r. Terminate with <return> only if there are less than the maximum number of digits, e.g. when entering a single digit rather than 2 for <byte> or when entering less than 4 characters for <address> etc. Note: do not prefix with &, hex is assumed.
\par (b)\tab 
by default if <return> alone is pressed. This has different effects depending on the command, and is not always allowed. In general though, a single address or the start address of a range will default to the 'current address' (see (iii) below); the secon
d
 address of a range will default to 'infinity' (i.e. the command will continue indefinitely); and a single byte will default to zero. Note that the second address can be entered relative to the first, using the '+' operator. eg L 6000+FF is equivalent to 
L 6000 60FF.
\par (c)\tab as an expression, using the '#' option (see (iv)b below). This allows decimal values to be input.
\par \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 (iii)}{\f1\fs24\cgrid0  }{\b\f1\fs24\cgrid0 The Current Address
\par }{\fs24\cgrid0 Used for default values (see (ii) above), and the address to start execution or simulation, this is altered by the command }{\i\fs24\cgrid0 @. }{\fs24\cgrid0 It is displayed at the top of the screen as PC.
\par }{\f1\fs24\cgrid0 \~
\par }{\b\f1\fs24\cgrid0 \page (iv) Expression Evaluation
\par }\pard \ql \fi-426\li426\ri0\nowidctlpar\faauto\adjustright\rin0\lin426\itap0 {\fs24\cgrid0 (a)\tab 
The 'C' command causes evaluation of an arithmetic expression, displaying the result as a 4 byte hex integer and decimal equivalent. Negative results are printed 
in 16 bit complement form (ie the result -10 is printed as 65526 etc). The expression may contain +, -, *, /, ^, brackets to any level, and, most useful of all, Basic variable names. In particular this includes labels used in the source code (provided the
y are still defined).
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 NOTE:\tab 
The expression evaluator makes use of routines in the Basic interpreter, and so reverts to the Basic convention of assuming decimal. You must therefore prefix hex numbers by &. If the Basic ROM is not installed, attempting to cal
l the expression evaluator will result in an error message to this effect. EXMON is compatible with versions 1 and 2 of BBC Basic in this respect.
\par }\pard \ql \fi-426\li426\ri0\nowidctlpar\faauto\adjustright\rin0\lin426\itap0 {\fs24\cgrid0 (b)\tab The '#' option. This allows fully general expressions to be entered for any of the parameters for any com
mand, if "#" is entered as the first character after the command letter, e.g. entering D#START #START + 22 will disassemble 23 bytes from the memory location given by 'START' (which may be a source code label). As a second example, entering @ #16041 will 
set PC to decimal 16041.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\i\f1\fs24\cgrid0 \~
\par }{\b\f1\fs24\cgrid0 (v) The Panel
\par }{\fs24\cgrid0 The panel is first displayed on entering EXMON, and the full panel can be recalled by pressing <return>. The top line of the panel shows the saved values of the 6502 registers which will be restored on executing a pr
ogram. The flags of the status register that are set are shown individually. Also the top 4 bytes on the stack (if any) are displayed. The top byte of the stack is on the left. The registers can all be altered with the 'A','X','Y','S','P' and '@' commands
.
\par The remainder of the panel is a memory listing. By default this lists the first half of zero-page but can be changed to any part of memory with the 'T' command.
\par }{\b\f1\fs24\cgrid0 
\par (vi) Operating System Commands
\par }\pard \ql \fi-426\li426\ri0\nowidctlpar\faauto\adjustright\rin0\lin426\itap0 {\fs24\cgrid0 (a)\tab All normal calls to the operating system (Commands prefixe
d by *) are accepted by EXMON, so that it is possible to set user keys, make *FX calls, perform *LOADs, etc. all from within EXMON. In particular *KEY can be used within the monitor to set up often used command sequences.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par (vii) Paged Roms
\par }{\fs24\cgrid0 Although EXMON r
esides at the same address as the other paged ROMs, it is capable of listing and disassembling them. To do this first select the required ROM by entering the following, ! <rom-id> where <rom-id> is the number between 0 and &F specifying the position of th
e
 desired RON. With the standard machine, C,D,E and F refer to the 4 sockets from left to right (though there is redundancy so that 0,4,8 and C all refer to the leftmost socket). The Basic ROM is normally inserted in the rightmost position. Once a ROM has 
b
een selected in this way, all commands that use memory between &8000 and &BFFF will use this ROM. This applies to the following commands: L, D, M, V, F, R. To discover the number of the currently selected ROM, enter !<return> . Initially (ie after *EXMON 
or Break) the Basic ROM will be selected regardless of where it resides.
\par }{\f1\fs24\cgrid0 \~
\par }{\b\f1\fs24\cgrid0 \page (viii) Zero-page Memory
\par }{\fs24\cgrid0 EXMON uses locations 08 to &4F as workspace. Locations from &50, ie those provided for the user, are all unused by EXMON and may therefore be freely used.
\par }{\b\f1\fs24\cgrid0 
\par (ix) Printing
\par }{\fs24\cgrid0 The output of a command will be sent to a printer if the command is preceded by 'H'
\par }\pard \ql \li1080\ri0\nowidctlpar\faauto\adjustright\rin0\lin1080\itap0 {\fs24\cgrid0 e.g.\tab HL8000\emdash 9000 or HD7000\emdash 7138
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 
This will be cancelled before the next command. Note that the default for the print command is the parallel interface. If you are using the serial RS423 interface, you must (as usual) configure the machine by entering the appropriate *FX calls -see User G
uide p. 418.
\par }{\f1\fs24\cgrid0 \~
\par }{\b\f1\fs24\cgrid0 (x) Input Correction
\par }{\fs24\cgrid0 <Delete> will cancel the current entry, except an expression entry.
\par <escape> will escape from any command except M, R, or I.
\par 
\par }{\f1\fs24\cgrid0 \~
\par }{\b\f1\fs36\cgrid0 \page 4. LISTING AND EDITING COMMANDS
\par }\pard \ql \li360\ri0\nowidctlpar\faauto\adjustright\rin0\lin360\itap0 {\b\f1\fs24\cgrid0 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\lang1036\langfe1031\cgrid0\langnp1036 L }{\f1\fs24\lang1036\langfe1031\cgrid0\langnp1036 = }{\b\f1\fs24\lang1036\langfe1031\cgrid0\langnp1036 LIST
\par }\pard\plain \s4\ql \li0\ri0\keepn\nowidctlpar\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20\lang1036\langfe1031\langnp1036 Syntax : L <range>
\par }\pard\plain \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs24\cgrid0 Effect : lists the memory in he
x and ASCII within the given range. The second address can be omitted and listing will continue indefinitely \emdash  stop by pressing Escape. Page mode is engaged so page through with Shift as usual.
\par }\pard \ql \li360\ri0\nowidctlpar\faauto\adjustright\rin0\lin360\itap0 {\b\f1\fs24\cgrid0 
\par }\pard\plain \s5\ql \li0\ri0\keepn\nowidctlpar\faauto\outlinelevel4\adjustright\rin0\lin0\itap0 \b\f1\fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20\lang1036\langfe1031\langnp1036 D = DISASSEMBLE
\par }\pard\plain \s4\ql \li0\ri0\keepn\nowidctlpar\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20\lang1036\langfe1031\langnp1036 Syntax : D <range>
\par }\pard\plain \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs24\cgrid0 Effect : Disassembles the 
given range of memory, listing standard 6502 mnemonics, hex and ASCII. ' ??' signifies unrecognized opcode. }{\fs24\lang1036\langfe1031\cgrid0\langnp1036 Page mode is engaged.
\par }\pard \ql \li360\ri0\nowidctlpar\faauto\adjustright\rin0\lin360\itap0 {\b\f1\fs24\lang1036\langfe1031\cgrid0\langnp1036 
\par }\pard\plain \s5\ql \li0\ri0\keepn\nowidctlpar\faauto\outlinelevel4\adjustright\rin0\lin0\itap0 \b\f1\fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20\lang1036\langfe1031\langnp1036 K = DISASSEMBLE & SAVE
\par }\pard\plain \s4\ql \li0\ri0\keepn\nowidctlpar\faauto\outlinelevel3\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20 Syntax : K <range> <filename>
\par }\pard\plain \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs24\cgrid0 Effect : Disassembles the range of memory, spooling to the specified fil
e. The first record of the file will contain the Basic command "AUTO", so that when the file is *EXEC'd from Basic, a Basic program will be created. This can be edited and run to reassemble the original section.
\par }\pard \ql \fi-1420\li3692\ri0\nowidctlpar\faauto\adjustright\rin0\lin3692\itap0 {\fs24\cgrid0 Notes:\tab (i)\tab Branch instructions are disassembled with relative rather than absolute addressing.
\par }\pard \ql \fi-568\li3692\ri0\nowidctlpar\faauto\adjustright\rin0\lin3692\itap0 {\fs24\cgrid0 \tab (ii)\tab The filename is restricted to 7characters.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par N = ASSEMBLE
\par }{\fs24\cgrid0 Syntax : N <address>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect : Enters the line assembler at the specified address.
\par Input 6502 mnemonics (only 1 per line) and these will be assembled at the address displayed. Labels can be used in the normal way.
\par <return>\tab \tab \tab Moves forward 1 byte.
\par }\pard \ql \li1846\ri0\nowidctlpar\faauto\adjustright\rin0\lin1846\itap0 {\fs24\cgrid0 <spacebar><return> \tab Moves back 1 byte.
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 <escape>\tab \tab \tab Terminate assembling.
\par }\pard \ql \li2520\ri0\nowidctlpar\faauto\adjustright\rin0\lin2520\itap0 {\fs24\cgrid0 NOTE:\tab This calls the assembler in the Basic ROM.
\par }{\f1\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 M = MOVE
\par }{\fs24\cgrid0 Syntax : M <range> <address>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect : Moves a memory block, specified by the range, and places it starting at <address>. This is an 'intelligent copy' in that it copes with overlapping ranges.

\par }{\f1\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 \page E = EDIT
\par }{\fs24\cgrid0 Syntax : E <address>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect : Enters the memory editor, starting at the specified address.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par Editor Commands
\par }\pard \ql \fi-1278\li3124\ri0\nowidctlpar\faauto\adjustright\rin0\lin3124\itap0 {\fs24\cgrid0 <byte>\tab If a byte value is entered this is stored at the current location, and you move to the next byte.
\par <return>\tab Move to next without changing.
\par <spacebar>\tab Move back one byte.
\par <escape>\tab Finish editing.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par " = INPUT STRING
\par }{\fs24\cgrid0 Syntax : " <address> <string>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 
Effect : Stores ASCII characters input from the keyboard, starting at the specified address. Control characters can be entered. (A full stop will be displayed as with the "L" command). Delete can be used. A maximum of 255 characters may be entered. Termin
ate and enter the string by pressing Escape (the Return key enters the Return character &0D and is not therefore used to terminate this command).
\par }{\f1\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 I = FILL
\par }{\fs24\cgrid0 Syntax : I <range> <byte>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect : Fills memory range with byte value.
\par }{\f1\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 V = VERIFY
\par }{\fs24\cgrid0 Syntax : V <range> <address>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect : Compares memory block <range> with block starting at <address>, listing any differences. Note: default on second address not allowed on I or V commands.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par FS = FIND STRING
\par }{\fs24\cgrid0 Syntax : FS <range> <string>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect : Searches for ASCII string
 (up to 128 characters) in given memory range. Any occurrences will be listed, giving the address of the start of the string. Note: Do not be confused by unexpected finds; such as the buffer where the monitor stores the search string, or in the screen mem
ory !
\par NOTE:\tab Do not enter quotation marks at the end of the string.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par FB }{\f1\fs24\cgrid0 = }{\b\f1\fs24\cgrid0 FIND BYTE
\par }{\fs24\cgrid0 Syntax : FB <range> <bytes>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect : As above, but string of hex bytes is entered.
\par }{\f1\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 \page T = CHANGE PANEL DISPLAY
\par }{\fs24\cgrid0 Syntax : T <range>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect : changes the range of memory display
ed on the panel (see 3 (v)). In this way the panel can easily be set to any range of memory that is of special interest during debugging eg. }{\fs24\lang1036\langfe1031\cgrid0\langnp1036 T 1700 +8F etc. }{\fs24\cgrid0 
Note: the listing can be turned off by entering T 1 <return> 0 <return>.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par <RETURN>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Pressing Return at any time will return the monitor to the panel display.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par }{\b\f1\fs24\lang1036\langfe1031\cgrid0\langnp1036 C = CALCULATE
\par }{\fs24\lang1036\langfe1031\cgrid0\langnp1036 Syntax : C <expression>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 
Effect : Evaluates expression and displays the result in hexadecimal (see 3(iv) a), and decimal (the value of the two least significant bytes). Basic I or II must be resident in the machine.
\par }{\f1\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 O = OSBYTE and OSWORD CALLS
\par }{\fs24\cgrid0 Syntax : OB <byte> <byte> <byte>
\par Or\tab OW <byte> <byte> <byte>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 
Effect : calls OSBYTE or OSWORD, putting the 3 bytes in A, X, Y respectively. The outputs displayed are the values of A, X, Y on exit. The stack and saved registers are unaffected.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par }{\b\f1\fs24\lang1036\langfe1031\cgrid0\langnp1036 Q=QUIT
\par }{\fs24\lang1036\langfe1031\cgrid0\langnp1036 Syntax : Q
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect : Quits EXMON and return
s to Basic. Type OLD <return> to recover any resident Basic (or assembler) program. Using *BASIC will have the same effect except that the EXMON heading will remain.
\par }{\f1\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 
\par }\pard \qc \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs36\cgrid0 \page 5. RELOCATION
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 
\par The relocator will take a machine code program in memory, move it to an
other specified location and attempt to correctly adjust the program so that it will run at the new location. There are several reasons which may make it impossible to relocate a given program, so programs that will need to be relocated must avoid these:

\par }\pard \ql \li360\ri0\nowidctlpar\faauto\adjustright\rin0\lin360\itap0 {\fs24\cgrid0 (i)\tab the interspersion of data throughout the program (like the way the BBC O.S. handles error messages). Data should be contained in a few continuous blocks.
\par (ii)\tab references to addresses within the program as immediate operands, or in look-up tables. For example if a program uses an action address table, which gives addresses within the program. The action addresses could be used as follows:
\par }\pard \ql \li1440\ri0\nowidctlpar\faauto\adjustright\rin0\lin1440\itap0 {\fs24\cgrid0 LDA AAL,X\tab get action address low byte
\par STA M1
\par LDA AAH,X get high byte
\par }{\fs24\lang1040\langfe1031\cgrid0\langnp1040 STA M2
\par JMP (M1)
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 This sequence is quite unrelocata
ble because the addresses are stored simply as data. Similarly, using LDA # address(hi-byte): STA Ml: LDA # address(lo-byte): STA M2, where 'address' is a source code label, is unrelocatable.
\par The way to avoid this problem is to store all such addresses in 
a relocatable address table. Store them as operands of instructions within the program, e.g. LDA addrl: LDA addr2: LDA addr3. The LDA instruction is merely a dummy which ensures that the addresses are relocated.
\par }{\b\f1\fs24\cgrid0 
\par R = RELOCATE
\par }\pard \ql \li720\ri0\nowidctlpar\faauto\adjustright\rin0\lin720\itap0 {\fs24\cgrid0 (i)\tab Syntax: R <range> <address>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect:\tab 
Relocates a program given by<(range> to the new address. This form assures the <range> contains pure program, with no data. The exact effect is to adjust all addresses in the program that lie within the range of the prog
ram. This form is only of use if the relocated program is to use the same workspace.
\par }\pard \ql \li720\ri0\nowidctlpar\faauto\adjustright\rin0\lin720\itap0 {\fs24\cgrid0 (ii)\tab Syntax: R <range> <address> <up to 3 subranges>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect:\tab The subranges (lying within <range>) specify areas of memory used for data, and which are therefore simply to 
be moved, not relocated. The rest is relocated as above, but now any references to addresses within the moved data blocks will also be relocated. If illegal subranges are entered, or they are entered out of order, 'Input error' will be given.
\par }{\f1\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 \page RELOCATOR ERROR MESSAGES
\par }{\fs24\cgrid0 Relocation will still occur even if errors are encountered, because most practical relocations will involve errors that can be corrected manually after relocation. There are 4 error messages that can be produced by the relocator.
\par }\pard \ql \fi-2130\li3976\ri0\nowidctlpar\faauto\adjustright\rin0\lin3976\itap0 {\fs24\cgrid0 Data at hhhh\tab 
Given if an unrecognized opcode is encountered in a relocation section. This would usually mean there is data mixed with program, or that the subranges were incorrectly specified.
\par Split at hhhh\tab Given if the start of a 'move-only' subrange occurs in the middle of an instruction.
\par Outside range at hhhh\tab Relative jumps need no relocation, so if one jumps outside the range of relocation it will be meaningless in the new version.
\par Overflow at hhhh\tab This unusual error occurs if a program residing in zero-page is relocated elsewhere, so some one byte zero-page operands need two bytes when relocated.
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\f1\fs24\cgrid0 \~
\par }\pard \ql \li720\ri0\nowidctlpar\faauto\adjustright\rin0\lin720\itap0 {\b\f1\fs36\cgrid0 \page 6. DEBUGGING AND SIMULATION
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 
\par EXMON provides two main ways of keeping track of what a program is doing: using breakpoints, and single step simulation.
\par }{\f1\fs24\cgrid0 \~
\par }{\b\f1\fs24\cgrid0 (i) Breakpoints
\par }{\fs24\cgrid0 
The program being debugged can be executed from the monitor with the 'GO' command (see below). This will run normally until it hits a breakpoint, when the current values of the registers will be saved and control will return to the monitor. The registe
r and memory contents can then be examined to check that the program has run correctly up to the breakpoint. If not, it can be corrected and run again, otherwise 'GO' can be used to continue to the next breakpoint.
\par Up to 5 breakpoints are allowed at a time, their addresses are displayed at the bottom of the screen. The appropriate commands are as follows:
\par }{\b\f1\fs24\cgrid0 
\par B }{\f1\fs18\cgrid0 = }{\b\f1\fs24\cgrid0 BREAKPOINT
\par }\pard \ql \li1080\ri0\nowidctlpar\faauto\adjustright\rin0\lin1080\itap0 {\fs24\cgrid0 Syntax:\tab B <addr>
\par }\pard \ql \li1846\ri0\nowidctlpar\faauto\adjustright\rin0\lin1846\itap0 {\fs24\cgrid0 Effect: \tab Puts breakpoint at address. This MUST be the address of the first byte of an instruction. An error message will 
be given if the byte in question is not a valid opcode. Note that with an instruction such as JSR &2020 [20,20,20], no error message would be given if a breakpoint is put at the middle byte, because it appears to be the START of a JSR instruction. When ex
ecuted a breakpoint will not occur, instead the instruction will become [20,0,20], which is JSR &2000.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par U = UNBREAKPOINT
\par }\pard \ql \li1080\ri0\nowidctlpar\faauto\adjustright\rin0\lin1080\itap0 {\fs24\cgrid0 Syntax:\tab U <addr>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect:\tab Removes breakpoint from address.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par W = WINDUP
\par }\pard \ql \li1080\ri0\nowidctlpar\faauto\adjustright\rin0\lin1080\itap0 {\fs24\cgrid0 Syntax:\tab W
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect:\tab Deletes all breakpoints.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par \page GO
\par }\pard \ql \li1080\ri0\nowidctlpar\faauto\adjustright\rin0\lin1080\itap0 {\fs24\cgrid0 Syntax:\tab GO
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect:\tab 
The stored values are restored to the 6502 registers and execution begins at the 'current address' (ie. the address displayed in the PC register on the panel - and altered with the @ command).
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 Notes
\par (a)\tab The effect of the 'B' command is to store the addres
s in the breakpoint table. The breakpoint is not put into the program until the 'GO' command is used. Therefore the program can be correctly disassembled and simulated whi1e breakpoints are in place.
\par (b)\tab Permanent breakpoints (i.e. those which form a permanent part of the program rather than those inserted with the 'B' command) have exactly the same effect.
\par (c)\tab CAUTION \emdash  if Break is pressed while a program is running, any breakpoints will not be removed; so the program will normally need to be re-assembled.
\par (d)\tab VERY IMPORTANT \emdash  Breakpoints must only be placed at the first byte of an instruction.
\par }{\f1\fs24\cgrid0 \~
\par \~
\par }{\b\f1\fs24\cgrid0 (ii) Simulation
\par }{\fs24\cgrid0 The monitor includes the extremely useful facility of being able to step through a program one instruction at a time. This is useful to examine a small part of a program in detail more easily than by using breakpoints.
\par Simulation will begin at the 'current address' (ie. the address given by PC at the top of the screen - which may be altered with the @ command), and is started by pressing the Spaceb
ar. The current instruction will be disassembled and displayed, along with the register contents, BEFORE executing it. Further presses of the Spacebar will cause the instruction to be executed, the new register contents and the next instruction to be disp
layed. There are two other related commands, '/' and 'Z' (see below).
\par Note : a running display will scroll up the screen; the top line will always show the correct register and stack contents.
\par }{\b\f1\fs24\cgrid0 
\par (Space-bar) = SINGLE STEP
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect:\tab If in simulation mode, execut
es current instruction; otherwise enters simulation mode. Displays registers and next instruction. Operating system calls will be executed as if one instruction.
\par }{\f1\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 / = SINGLE STEP ON ONE LEVEL
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect:\tab 
As above unless the current instruction is a 'JSR' call. In this case the subroutine is executed as one instruction. This is useful when certain subroutines are known to be working.
\par Note this only operates in simulation mode.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 
\par \page Z = SIMULATE
\par }\pard \ql \li1080\ri0\nowidctlpar\faauto\adjustright\rin0\lin1080\itap0 {\fs24\cgrid0 Syntax:\tab Z <byte>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect:\tab 
Simulates a series of instructions in succession, displaying them on the way. This is equivalent to pressing the Spacebar N times in succession during simulation, where N is the byte value entered.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 Note
\par While in simulation mode any other command can be entered normally, causing automatic exit. In particular the register commands (below) can be entered immediately to simulate particular conditions.
\par }{\b\f1\fs24\cgrid0 
\par (iii) Register Commands
\par }{\fs24\cgrid0 The following commands change the saved values for the registers which are restored by 'GO', 'J', and the simulator commands.
\par }\pard \ql \li2160\ri0\nowidctlpar\faauto\adjustright\rin0\lin2160\itap0 {\fs24\cgrid0 A (byte>\tab set accumulator.
\par X <byte>\tab set X register.
\par Y <byte>\tab set Y register.
\par P <byte>\tab set processor status. (PSW)
\par S <byte>\tab set stack pointer.
\par Note:\tab <byte> defaults to &FF, i.e. empty stack.
\par @ <address>\tab set program counter/current address.
\par \~
\par }{\f1\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 (iv) Subroutine Testing
\par }{\fs24\cgrid0 The following command is provided to enable the testing of a subroutine in isolation. It can also be used to execute a program that will not return.
\par J = JSR
\par }\pard \ql \li1080\ri0\nowidctlpar\faauto\adjustright\rin0\lin1080\itap0 {\fs24\cgrid0 Syntax:\tab J <address>
\par }\pard \ql \li1800\ri0\nowidctlpar\faauto\adjustright\rin0\lin1800\itap0 {\fs24\cgrid0 Effect:\tab Performs JSR to given address, after restoring registers. Saves and displays the registers on return.
\par Note breakpoints are not inserted by this command.
\par \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 
\par }{\f1\fs24\cgrid0 \~
\par }{\b\f1\fs36\cgrid0 \tab 
\par \page EXMON COMMAND SUMMARY
\par 
\par }{\b\f1\fs24\cgrid0 1. GENERAL
\par }\pard \ql \fi-3600\li3600\ri0\nowidctlpar\faauto\adjustright\rin0\lin3600\itap0 {\fs24\cgrid0 *EXMON (or *E) <return>\tab Enter EXMON
\par ?\tab Display HELP summary.
\par }\pard\plain \s1\ql \fi-3600\li3600\ri0\keepn\nowidctlpar\faauto\outlinelevel0\adjustright\rin0\lin3600\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20 BREAK\tab Clears all registers, and re-initializes EXMON
\par }\pard\plain \ql \fi-3600\li3600\ri0\nowidctlpar\faauto\adjustright\rin0\lin3600\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs24\lang1036\langfe1031\cgrid0\langnp1036 Q\tab Quit EXMON.
\par }{\fs24\cgrid0 *\tab Permits all normal calls to operating system.
\par H <command>\tab Send output of command to printer.
\par #\tab All data and addresses are assumed to be in hex unless proceeded by #.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 \~
\par 2. MEMORY LISTING AND EDITING
\par }{\fs24\cgrid0 L\tab <range>\tab \tab \tab List memory (hex.& ASCII).
\par D\tab <range>\tab \tab \tab Disassemble memory.
\par K\tab <range> <filename>\tab \tab Disassemble and save to file.
\par N\tab <addr>\tab \tab \tab \tab Assemble. <escape> to end.
\par E\tab <addr>\tab \tab \tab \tab Edit memory:
\par \tab editor commands:
\par }\pard \ql \li720\ri0\nowidctlpar\faauto\adjustright\rin0\lin720\itap0 {\fs24\cgrid0 <byte>\tab \tab \tab \tab change byte, move to next byte.
\par <return>\tab \tab \tab move to next byte.
\par <space-bar>\tab \tab \tab move to previous byte.
\par <escape>\tab \tab \tab exit editor.
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 \tab <addr> <string> <escape>\tab Input ASCII string to memory.
\par FS\tab <range> <string>\tab \tab Find ASCII string in given range. **
\par FB\tab <range> <bytes>\tab \tab Find string of hex bytes.
\par M\tab <rangeA> <addrA>\tab \tab Move memory block.
\par }\pard\plain \s18\ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20 V\tab <rangeA> <addrA>\tab \tab Verify that two memory blocks are the same.
\par }\pard\plain \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs24\cgrid0 I\tab <rangeA> <byte>\tab \tab Fill memory with given byte.
\par T\tab <rangeA>\tab \tab \tab Change panel display.
\par <return>\tab \tab \tab \tab Return to panel.
\par C\tab <expression>\tab \tab \tab Calculate value of expression.
\par O\tab <3 bytes>\tab \tab \tab JSR OSBYTE.
\par OW\tab <3 bytes>\tab \tab \tab JSR OSWORD.
\par !\tab <byte>\tab \tab \tab \tab change currently selected ROM.
\par !\tab <return>\tab \tab \tab Display the number of the current ROM.
\par }\pard\plain \s2\ql \li0\ri0\keepn\nowidctlpar\faauto\outlinelevel1\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20 R\tab <rangeA> <addrA> <0 to 3 rangeAs>
\par }\pard\plain \s17\ql \li3600\ri0\nowidctlpar\faauto\adjustright\rin0\lin3600\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20 Relocate memory block, not relocating specified sub-ranges, otherwise adjusting all addresses in the range.

\par }\pard\plain \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs24\cgrid0 **\tab NOTE: Do not enter quotation marks at the end of the string.
\par }{\b\f1\fs24\cgrid0 \~
\par \page 3. DEBUGGING AND SIMULATION
\par }{\fs24\cgrid0 @ <addr>\tab Set program counter.
\par A <byte>\tab Set accumulator.
\par X <byte>\tab Set X register.
\par Y <byte>\tab Set Y register.
\par P <byte>\tab Set }{\fs18\cgrid0 PSW.
\par }{\fs24\cgrid0 S <byte>\tab Set stack pointer.
\par }\pard\plain \s15\ql \fi-1440\li1440\ri0\nowidctlpar\faauto\adjustright\rin0\lin1440\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20 GO\tab Execute program from current PC address.
\par <space-bar>\tab Enter simulation mode. If already simulating then step one instruction. Step one instruction, treating a JSR as a single instruction. 
\par Z <byte>\tab Simulate <byte> instructions.
\par }\pard\plain \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs24\cgrid0 B <addr>\tab Create breakpoint.
\par U <addr>\tab Delete breakpoint.
\par }\pard\plain \s15\ql \fi-1440\li1440\ri0\nowidctlpar\faauto\adjustright\rin0\lin1440\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20 W\tab Delete all breakpoints.
\par }\pard\plain \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs24\cgrid0 J <addrA>\tab JSR to given address.
\par }{\f1\fs24\cgrid0 
\par 
\par 
\par }{\b\f1\fs24\cgrid0 4. SYNTAX DEFINITIONS
\par }\pard\plain \s16\ql \fi-2160\li2160\ri0\nowidctlpar\faauto\adjustright\rin0\lin2160\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20 <addr>\tab An address in hex of up to 4 digits. Terminate with Return if less than 4 hex di
gits. Return on empty input defaults to current PC address. Ie <4 hex digits> or <1-3 hex digits> <return> or (return> or # <expression>.
\par }\pard\plain \ql \fi-2160\li2160\ri0\nowidctlpar\faauto\adjustright\rin0\lin2160\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs24\cgrid0 <addrA>\tab As <addr> except that Return on an empty input is not allowed.
\par <range>\tab Two addresses (a start address and an e
nd address) in hex of up to 4 digits. Both addresses as <addr> above. ie <addr> <addr> or <addr> <return> <addr> <return> (Return on an empty second address defaults to continuous listing). An alternative form is <addr> }{\fs18\cgrid0 + }{\fs24\cgrid0 
<addr> where the second "addr" is an increment. (This is achieved in such a way that, for example, the range 3000 + 9 is taken to be the range 3000 to 3009 inclusive.) As suggested above <addr> may be replaced by #<expression>.
\par <rangeA>\tab As <range> except that pressing Return on an empty string for the first address defaults to the value of }{\fs18\cgrid0 PC. }{\fs24\cgrid0 No default is allowed on the second address.
\par }\pard\plain \s16\ql \fi-2160\li2160\ri0\nowidctlpar\faauto\adjustright\rin0\lin2160\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20 <byte>\tab 
A byte of data input as two hex digits (ie 00 to FF), or a single hex digit followed by <return>, or #<expression>. Pressing Return on empty data returns a zero (except with the 'S' command).
\par }\pard\plain \ql \fi-2160\li2160\ri0\nowidctlpar\faauto\adjustright\rin0\lin2160\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs24\cgrid0 <expression>\tab A general expression involving }{\fs18\cgrid0 +, \emdash , }{\i\fs18\cgrid0 *, }{
\fs24\cgrid0 /, }{\fs18\cgrid0 ^, }{\fs24\cgrid0 brackets, variable names (e.g assembly source code labels). Expressions must be preceded by #.
\par }\pard\plain \s16\ql \fi-2160\li2160\ri0\nowidctlpar\faauto\adjustright\rin0\lin2160\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20 <filename>\tab A name of up to 7 characters to be used when saving a disassembly to tape or disc.

\par }\pard\plain \ql \li2880\ri0\nowidctlpar\faauto\adjustright\rin0\lin2880\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs24\cgrid0 \~
\par }{\f1\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\b\f1\fs24\cgrid0 \page 5. NOTES
\par }\pard\plain \s15\ql \fi-1440\li1440\ri0\nowidctlpar\faauto\adjustright\rin0\lin1440\itap0 \fs24\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\fs20 <Delete>\tab 
Cancels current entry (except on expression entry, and when using the " command, where it deletes normally).
\par <escape>\tab Cancels current entry, escapes from any command except M, R, I.
\par <Break>\tab Clears\tab all registers and re-initializes EXMON.
\par <expression>\tab A general expression involving +, -, *1 /, ^,brackets, variable names (e.g assembly source code labels). Expressions must be preceded by #.<filename> A name of up to 7 characters to be used when saving a disassembly to tape or disc.

\par }\pard\plain \ql \li2880\ri0\nowidctlpar\faauto\adjustright\rin0\lin2880\itap0 \fs20\lang1033\langfe1031\cgrid\langnp1033\langfenp1031 {\f1\fs24\cgrid0 \~
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\adjustright\rin0\lin0\itap0 {\fs24\cgrid0 
\par }}